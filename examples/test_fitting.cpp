#include <cmath>
#include <iostream>

#include <Eigen/Core>
#include <unsupported/Eigen/NonLinearOptimization>

#include <matplot/matplot.h>

/*
Curve fitting test with the Levenberg-Marquardt algorithm as provided in the
Eigen API.

The program fits points generated by sampling the curve f(x) = a * x^2 + b * x + c
with a = -2, b= 50, c = 10 with random noise
(see https://medium.com/@sarvagya.vaish/levenberg-marquardt-optimization-part-2-5a71f7db27a0).
*/

Eigen::ArrayXXd generateSamples(size_t numSamples)
{
  Eigen::ArrayXd x = Eigen::ArrayXd::LinSpaced(numSamples, -5.0, 25.0);
  Eigen::ArrayXXd points(numSamples, 2);
  for (size_t i = 0; i < numSamples; ++i) {
    points(i, 0) = x(i);
    points(i, 1) = -2.0 * std::pow(x(i), 2) + 50.0 * x(i) + 10.0 + drand48() * 10.0;
  }
  return points;
}

// Generic functor
template<typename _Scalar, int NX = Eigen::Dynamic, int NY = Eigen::Dynamic> struct Functor
{
  typedef _Scalar Scalar;
  enum { InputsAtCompileTime = NX, ValuesAtCompileTime = NY };
  typedef Eigen::Matrix<Scalar, InputsAtCompileTime, 1> InputType;
  typedef Eigen::Matrix<Scalar, ValuesAtCompileTime, 1> ValueType;
  typedef Eigen::Matrix<Scalar, ValuesAtCompileTime, InputsAtCompileTime> JacobianType;

  int m_inputs, m_values;

  Functor() :
    m_inputs(InputsAtCompileTime),
    m_values(ValuesAtCompileTime)
  {}
  Functor(int inputs, int values) :
    m_inputs(inputs),
    m_values(values)
  {}

  int inputs() const { return m_inputs; }
  int values() const { return m_values; }
};

struct MyFunctor : Functor<double>
{

  Eigen::ArrayXXd samples;
  
  int operator()(const Eigen::VectorXd& x, Eigen::VectorXd& fvec) const
  {
    // x here is vector of fitting params
    for (size_t i = 0; i < this->samples.rows(); ++i) {
      fvec(i) = this->samples(i, 1) -
                (x(0) * std::pow(this->samples(i, 0), 2) + x(1) * this->samples(i, 0) + x(2)); // Errors at each sample
    }
    return 0;
  }

  int inputs() const { return 3; } // Number of fitting params
  int values() const { return this->samples.rows(); } // Number of samples to fit
};

struct MyFunctorNumericalDiff : Eigen::NumericalDiff<MyFunctor>
{
};

int main()
{
  // Generate samples
  Eigen::ArrayXXd samples = generateSamples(50);
  std::vector<double> xSample(samples.rows()), ySample(samples.rows());

  Eigen::ArrayXd::Map(&xSample[0], samples.rows()) = samples.col(0);
  Eigen::ArrayXd::Map(&ySample[0], samples.rows()) = samples.col(1);

  // Setup
  Eigen::VectorXd x(3);
  // Initial guess
  x.fill(0.0);

  MyFunctorNumericalDiff functor;
  functor.samples = samples;
  Eigen::LevenbergMarquardt<MyFunctorNumericalDiff> lm(functor);
  lm.parameters.maxfev = 2000;
  lm.parameters.xtol = 1e-10;

  int status = lm.minimize(x);
  std::cout << "Number of iterations: " << lm.iter << '\n';
  std::cout << "Status: " << status << '\n';
  std::cout << "Fitting result: " << x << '\n' << '\n';

  // Plot results
  auto xFit = matplot::linspace(-5.0, 25.0, 100);
  auto yFit = matplot::transform(xFit, [&](double t) { return x(0) * std::pow(t, 2) + x(1) * t + x(2); });

  matplot::figure();
  matplot::scatter(xSample, ySample);
  matplot::hold(matplot::on);
  matplot::plot(xFit, yFit)->line_width(2).color("red");
  matplot::show();
}
